1ï¸âƒ£ First: what problem are we solving?

You want:

React state âœ…

State should remember value after refresh âœ…

React state alone cannot do this.

So you say:
ğŸ‘‰ â€œWhen the component loads, read the value from localStorage and put it into state.â€

Thatâ€™s WHY we are doing this.

2ï¸âƒ£ The code in question
const [name, setName] = useState(() => {
  return localStorage.getItem("name") || "";
});

Now the real question is:

â“ Why inside useState
â“ Why not outside
â“ Why function instead of direct value

3ï¸âƒ£ What useState really does (important ğŸ§ )
useState(initialValue)


React does 2 things:

1ï¸âƒ£ On first render (mount)

It sets state = initialValue

2ï¸âƒ£ On re-renders

It ignores initialValue

It keeps the existing state

ğŸ“Œ This means:

initialValue is used only once

4ï¸âƒ£ Case 1: âŒ WRONG / less optimal way
const storedName = localStorage.getItem("name");

const [name, setName] = useState(storedName || "");

What happens?

localStorage.getItem() runs

on first render âŒ

on every re-render âŒ

React still uses it only once, but JS keeps executing it

ğŸ“ This is wasted work

5ï¸âƒ£ Case 2: âŒ Still not ideal
const [name, setName] = useState(localStorage.getItem("name") || "");

What happens?

localStorage.getItem() runs:

every render âŒ

React ignores it after first render

But browser still reads localStorage again & again

6ï¸âƒ£ Case 3: âœ… BEST way (your code)
const [name, setName] = useState(() => {
  return localStorage.getItem("name") || "";
});

Why this is special?

This is called lazy initialization.

What React does:

On first render only:

React calls this function

Reads from localStorage

Sets initial state

On re-renders:

React does NOT call this function

State stays the same

ğŸ§  So:

localStorage is read only once

7ï¸âƒ£ Why reading localStorage only once matters?

Because:

localStorage access is synchronous

It can be slow

Reading it on every render is bad practice

ğŸ“Œ React performance rule:

â€œDo expensive work only once if possible.â€

8ï¸âƒ£ Mental model (remember this forever)

Think like this ğŸ‘‡

ğŸ§  â€œWhen component is born, ask localStorage
After that, trust React state.â€

Why is useEffect not recommended for reading initial data from localStorage, even when the dependency array is empty []?

âœ… Short Answer

Because useEffect runs after the first render, and calling setState inside it causes one extra render.
Using useState lazy initialization sets the value during the first render, avoiding unnecessary re-render.

ğŸ§  Explanation (Simple & Clear)

useEffect(() => {}, []) runs only once, but after the first render

Initial render happens with default state

setState inside useEffect updates state

React performs one additional render

ğŸ‘‰ This extra render is avoidable

ğŸ”„ Render Comparison
Using useEffect

First render â†’ state is empty

useEffect runs â†’ state updated

Second render â†’ correct value shown

âŒ 2 renders

Using useState lazy initialization

First render â†’ state already has correct value

âœ… 1 render

ğŸ¯ Key Point to Remember

useEffect is for side effects, not for setting initial state.